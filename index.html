<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HOPR Channels Manager</title>
</head>
<body>

<h1>HOPR Channels Manager</h1>
<p>This tool gives an overview of the current (v4) HOPR payment channels. All contracts on <strong>Gnosis Chain</strong>. Calls go through your connected wallet's RPC.</p>

<hr>

<h2>Wallet</h2>
<button onclick="connectWallet()">Connect Wallet</button>
<span id="walletStatus">Not connected</span>
&nbsp;&nbsp;|&nbsp;&nbsp;
wxHOPR balance: <strong id="tokenBalance">--</strong>
<button onclick="refreshBalance()" title="Refresh balance">&#8635;</button>

<hr>

<h2>Contracts</h2>
<table>
  <tr>
    <td><label for="tokenAddr">wxHOPR Token:</label></td>
    <td><input id="tokenAddr" size="46" value="0xD4fdec44DB9D44B8f2b6d529620f9C0C7066A2c1"></td>
  </tr>
  <tr>
    <td><label for="channelsAddr">HoprChannels:</label></td>
    <td><input id="channelsAddr" size="46" value="0x69E63A01a2209F733C83ECa619ddDa2BEA4d5Cdf"></td>
  </tr>
</table>

<hr>

<h2>TicketRedeemed Activity</h2>
<table>
  <tr>
    <td><label for="hmFromBlock">From block:</label></td>
    <td><input id="hmFromBlock" value="44027565" size="12"></td>
    <td>&nbsp;&nbsp;<label for="hmToBlock">To block:</label></td>
    <td><input id="hmToBlock" placeholder="latest" size="12"></td>
    <td>&nbsp;<button id="hmFetchLatestBtn" onclick="fetchLatestBlock()">Fetch latest</button></td>
  </tr>
  <tr>
    <td><label for="hmLogRange">Block range per log query:</label></td>
    <td><input id="hmLogRange" type="number" value="10000" min="1" size="10"></td>
    <td>&nbsp;&nbsp;<label for="hmBatchSize">Blocks per timestamp batch:</label></td>
    <td><input id="hmBatchSize" type="number" value="100" min="1" size="6"></td>
  </tr>
</table>
<button id="hmLoadBtn" onclick="loadHeatmap()">Load</button>
<button id="hmPauseBtn" onclick="pauseResumeHeatmap()" disabled>Pause</button>
<button id="hmAbortBtn" onclick="abortHeatmap()" disabled>Abort</button>
<br><br>
<div id="hmProgress" style="display:none">
  <progress id="hmBar" value="0" max="100" style="width:300px"></progress>
  <span id="hmBarText"></span>
</div>
<div id="hmOutput"></div>

<hr>

<h2>Channel</h2>

<fieldset>
  <legend>From</legend>
  <select id="fromSelect" onchange="onSelectChange('from')">
    <option value="">-- select relay --</option>
    <option value="0xc00b7d90463394ec29a080393ff09a2ed82a0f86">relay to UK      (0xc00b...0f86)</option>
    <option value="0x6250eb481b40f4609d32de35bd9b827212713f35">relay to Brazil  (0x6250...3f35)</option>
    <option value="0xfe3af421afb84eed445c2b8f1892e3984d3e41ea">relay to USA     (0xfe3a...41ea)</option>
    <option value="0xee7c14d7081cdeed6503478db0bfc26e4353feef">relay to Australia (0xee7c...feef)</option>
    <option value="0x8f40df42bba9fa560bdf0b66a0d964a9a1ee85c3">relay to India   (0x8f40...85c3)</option>
    <option value="0x16a8c54a8ac982d167adae90781e0f822ed1db2d">relay to S.Korea (0x16a8...db2d)</option>
  </select>
  &nbsp;or custom:&nbsp;
  <input id="fromCustom" size="44" placeholder="0x..." oninput="onCustomInput('from')">
</fieldset>

<fieldset>
  <legend>To</legend>
  <select id="toSelect" onchange="onSelectChange('to')">
    <option value="">-- select relay --</option>
    <option value="0xc00b7d90463394ec29a080393ff09a2ed82a0f86">relay to UK      (0xc00b...0f86)</option>
    <option value="0x6250eb481b40f4609d32de35bd9b827212713f35">relay to Brazil  (0x6250...3f35)</option>
    <option value="0xfe3af421afb84eed445c2b8f1892e3984d3e41ea">relay to USA     (0xfe3a...41ea)</option>
    <option value="0xee7c14d7081cdeed6503478db0bfc26e4353feef">relay to Australia (0xee7c...feef)</option>
    <option value="0x8f40df42bba9fa560bdf0b66a0d964a9a1ee85c3">relay to India   (0x8f40...85c3)</option>
    <option value="0x16a8c54a8ac982d167adae90781e0f822ed1db2d">relay to S.Korea (0x16a8...db2d)</option>
  </select>
  &nbsp;or custom:&nbsp;
  <input id="toCustom" size="44" placeholder="0x..." oninput="onCustomInput('to')">
</fieldset>

<br>
<button onclick="queryChannel()">Query Channel</button>

<hr>

<h2>Result</h2>
<pre id="output">--</pre>

<hr>

<h2>Events</h2>
<p>Fetches all channel events from block 0 to latest, filtered by the current channel ID.</p>
<button onclick="loadEvents()">Load Events</button>
<pre id="eventsOutput">--</pre>

<hr>

<h2>Top Up Channel</h2>
<p>
  Calls <code>wxHOPR.send(channelsContract, amount, userData)</code> where<br>
  <code>userData = abi.encodePacked(from, amount_uint96, to, uint96(0))</code>.<br>
  Uses the From / To addresses selected above. Your wallet must hold wxHOPR.
</p>
<label>Amount (HOPR):&nbsp;<input id="topUpAmount" type="number" min="0" step="any" placeholder="e.g. 10"></label>
&nbsp;<button onclick="topUpChannel()">Top Up Channel</button>
<br><br>
<span id="topUpStatus"></span>

<div id="hm-tooltip" style="position:fixed;display:none;pointer-events:none;background:#222;color:#eee;padding:3px 8px;font-family:monospace;font-size:12px;white-space:nowrap"></div>

<script>
  // ── Wallet ────────────────────────────────────────────────────────────────

  let walletAddr       = null;
  let currentChannelId = null;

  const GNOSIS_CHAIN_ID = '0x64'; // 100 decimal

  async function ensureGnosisChain() {
    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
    if (chainId === GNOSIS_CHAIN_ID) return;

    try {
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: GNOSIS_CHAIN_ID }],
      });
    } catch (e) {
      // Error 4902: chain not yet added to the wallet — add it.
      if (e.code === 4902) {
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId:         GNOSIS_CHAIN_ID,
            chainName:       'Gnosis Chain',
            nativeCurrency:  { name: 'xDAI', symbol: 'xDAI', decimals: 18 },
            rpcUrls:         ['https://rpc.gnosischain.com'],
            blockExplorerUrls: ['https://gnosisscan.io'],
          }],
        });
      } else {
        throw e;
      }
    }
  }

  async function connectWallet() {
    if (!window.ethereum) {
      alert('No EIP-1193 wallet found. Install MetaMask or similar.');
      return;
    }
    try {
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      walletAddr = accounts[0];
      await ensureGnosisChain();
      document.getElementById('walletStatus').textContent = 'Connected: ' + walletAddr;
      await refreshBalance();
      loadHeatmap();
    } catch (e) {
      document.getElementById('walletStatus').textContent = 'Connection rejected: ' + (e.message ?? e);
    }
  }

  // Warn if the user manually switches away from Gnosis Chain after connecting.
  window.ethereum?.on('chainChanged', (chainId) => {
    if (chainId !== GNOSIS_CHAIN_ID) {
      document.getElementById('walletStatus').textContent =
        'Wrong network (chain ' + parseInt(chainId, 16) + ') — please switch to Gnosis Chain';
    }
  });

  async function refreshBalance() {
    if (!walletAddr) { alert('Connect wallet first'); return; }
    const tokenAddr = document.getElementById('tokenAddr').value.trim();
    try {
      // balanceOf(address)  →  uint256
      const data   = '0x70a08231' + abiAddress(walletAddr);
      const result = await ethCall(tokenAddr, data);
      const bal    = BigInt(result);
      document.getElementById('tokenBalance').textContent = formatHOPR(bal);
    } catch (e) {
      document.getElementById('tokenBalance').textContent = 'error';
    }
  }

  // ── Address helpers ────────────────────────────────────────────────────────

  function onSelectChange(side) {
    const val = document.getElementById(side + 'Select').value;
    if (val) document.getElementById(side + 'Custom').value = val;
  }

  function onCustomInput(side) {
    document.getElementById(side + 'Select').value = '';
  }

  function getAddress(side) {
    const custom = document.getElementById(side + 'Custom').value.trim();
    const sel    = document.getElementById(side + 'Select').value;
    return custom || sel;
  }

  // ── ABI encoding (manual, no deps) ────────────────────────────────────────

  // Pad a hex address (with or without 0x) to a 32-byte ABI word
  function abiAddress(addr) {
    return addr.toLowerCase().replace(/^0x/, '').padStart(64, '0');
  }

  // Pass a raw 32-byte hex value (with or without 0x) as a bytes32 ABI word
  function abiBytes32(hex) {
    return hex.replace(/^0x/, '').padStart(64, '0');
  }

  // ── eth_call via wallet provider ──────────────────────────────────────────

  async function ethCall(to, data) {
    return window.ethereum.request({
      method: 'eth_call',
      params: [{ to, data }, 'latest'],
    });
  }

  // ── Channel struct decoding ────────────────────────────────────────────────

  // channels() returns: balance uint96, ticketIndex uint48, closureTime uint32,
  //                     epoch uint24, status uint8
  // ABI-encoded: each field padded to 32 bytes (right-aligned / big-endian).
  function decodeChannelStruct(hex) {
    const h = hex.replace(/^0x/, '');
    const word = (n) => BigInt('0x' + (h.slice(n * 64, n * 64 + 64) || '0'));

    const STATUS_NAMES = ['CLOSED', 'WAITING_FOR_COMMITMENT', 'OPEN', 'PENDING_TO_CLOSE'];
    const status = word(4);

    return {
      balance:      word(0),
      ticketIndex:  word(1),
      closureTime:  word(2),
      epoch:        word(3),
      status,
      statusName:   STATUS_NAMES[Number(status)] ?? 'UNKNOWN(' + status + ')',
    };
  }

  // Format a raw uint256 wei value as a decimal token amount with 18 decimals.
  // Uses BigInt throughout to avoid floating-point precision loss.
  function formatHOPR(wei) {
    const UNIT = 10n ** 18n;
    const whole = wei / UNIT;
    const frac  = wei % UNIT;
    if (frac === 0n) return whole.toString() + ' HOPR';
    const fracStr = frac.toString().padStart(18, '0').replace(/0+$/, '');
    return whole.toString() + '.' + fracStr + ' HOPR';
  }

  // ── Main query ────────────────────────────────────────────────────────────

  async function queryChannel() {
    if (!window.ethereum) { alert('Connect wallet first'); return; }

    const from         = getAddress('from');
    const to           = getAddress('to');
    const channelsAddr = document.getElementById('channelsAddr').value.trim();

    if (!from) { alert('Provide a "From" address'); return; }
    if (!to)   { alert('Provide a "To" address');   return; }

    const out = document.getElementById('output');
    out.textContent = 'Querying…';

    try {
      // Step 1: _getChannelId(address from, address to)  →  bytes32
      const getIdCalldata = '0xbe9babdc' + abiAddress(from) + abiAddress(to);
      const channelIdRaw  = await ethCall(channelsAddr, getIdCalldata);
      currentChannelId = channelIdRaw;

      // Step 2: channels(bytes32 channelId)  →  Channel struct
      const channelsCalldata = '0x7a7ebd7b' + abiBytes32(channelIdRaw);
      const channelInfoRaw   = await ethCall(channelsAddr, channelsCalldata);

      const ch = decodeChannelStruct(channelInfoRaw);

      out.textContent = [
        'From:          ' + from,
        'To:            ' + to,
        'Channel ID:    ' + channelIdRaw,
        '',
        'balance:       ' + formatHOPR(ch.balance) + '  (raw: ' + ch.balance + ')',
        'ticketIndex:   ' + ch.ticketIndex,
        'closureTime:   ' + ch.closureTime,
        'epoch:         ' + ch.epoch,
        'status:        ' + ch.statusName + '  (' + ch.status + ')',
      ].join('\n');

    } catch (e) {
      out.textContent = 'Error: ' + (e.message || JSON.stringify(e));
    }
  }

  // ── Events ────────────────────────────────────────────────────────────────

  async function loadEvents() {
    if (!window.ethereum)    { alert('Connect wallet first');                return; }
    if (!currentChannelId)   { alert('Query a channel first to get its ID'); return; }

    const channelsAddr = document.getElementById('channelsAddr').value.trim();
    const out = document.getElementById('eventsOutput');
    out.textContent = 'Loading…';

    try {
      // topic0 hashes verified with: cast keccak '<signature>'
      const TOPICS = {
        '0x004c0177ad15bb302b4419e9ac96065d6f436e0f61972f97bbe272834c40f934': 'ChannelOpened',
        '0xec21547ca1e22edc3f9b4f4e0da94638b5b94dcb18d52dcc072abe5801a8013c': 'ChannelBalanceIncreased',
        '0x0c4672f14b63bb6354fac475ee498055a2784455673af224717b9770fd68d8d1': 'ChannelBalanceDecreased',
        '0x0061e8037197b4d91cf8add2a0736613459081f236d1c8ab58549ebbc330b4e3': 'OutgoingChannelClosureInitiated',
        '0x197bba684a6afb7ba24f1d265605414b1d0051a6e295d6ff7b6e78e870d7a7f0': 'ChannelClosed',
        '0xed22f34d154d253a7f6fd477439be59080a1554aa0d0642686d64223ab544c8a': 'TicketRedeemed',
      };
      const topics0 = Object.keys(TOPICS);
      const NAMES   = TOPICS;

      // Single eth_getLogs call:
      //   topics[0]  OR of all 6 event signatures
      //   topics[1]  channelId (first indexed param in every one of these events)
      const logs = await window.ethereum.request({
        method: 'eth_getLogs',
        params: [{
          address:   channelsAddr,
          topics:    [topics0, currentChannelId],
          fromBlock: '0x0',
          toBlock:   'latest',
        }],
      });

      if (logs.length === 0) {
        out.textContent = 'No events found for channel ' + currentChannelId;
        return;
      }

      // Fetch timestamps for all unique block numbers in parallel.
      const uniqueBlockNums = [...new Set(logs.map(l => l.blockNumber))];
      const blockTimes = {};
      await Promise.all(uniqueBlockNums.map(async (hexNum) => {
        const block = await window.ethereum.request({
          method: 'eth_getBlockByNumber',
          params: [hexNum, false],
        });
        const ts = parseInt(block.timestamp, 16);
        // Format as "YYYY-MM-DD HH:MM:SS UTC"
        blockTimes[hexNum] = new Date(ts * 1000).toISOString().replace('T', ' ').slice(0, 19) + ' UTC';
      }));

      const lines = ['--- ' + logs.length + ' event(s) for channel ' + currentChannelId + ' ---'];
      for (const [i, log] of logs.entries()) {
        const name  = NAMES[log.topics[0]] ?? log.topics[0];
        const block = parseInt(log.blockNumber, 16);
        lines.push('');
        lines.push('[' + (i + 1) + '] ' + name);
        lines.push('    time:    ' + blockTimes[log.blockNumber] + '  (block #' + block + ')');
        lines.push('    tx:      ' + log.transactionHash);
        if (name === 'ChannelOpened') {
          // ChannelOpened has source (topic[2]) and destination (topic[3]) indexed
          lines.push('    source:  0x' + log.topics[2].slice(-40));
          lines.push('    dest:    0x' + log.topics[3].slice(-40));
        }
        // The non-indexed `bytes32 channel` field is always in log.data
        if (log.data && log.data !== '0x') {
          lines.push('    channel: ' + log.data);
        }
      }
      out.textContent = lines.join('\n');

    } catch (e) {
      out.textContent = 'Error: ' + (e.message || JSON.stringify(e));
    }
  }

  // ── Top Up Channel ────────────────────────────────────────────────────────

  // Parse a human-readable HOPR amount string (e.g. "17.5") into wei as BigInt.
  // Handles up to 18 decimal places; truncates any excess.
  function parseHOPR(str) {
    const [whole = '0', frac = ''] = str.trim().split('.');
    const fracNorm = frac.padEnd(18, '0').slice(0, 18);
    return BigInt(whole || '0') * 10n ** 18n + BigInt(fracNorm);
  }

  // Encode the ERC777 send() calldata.
  //
  // Solidity equivalent:
  //   bytes memory userData = abi.encodePacked(from, uint96(amount), to, uint96(0));
  //   token.send(channelsAddr, amount, userData);
  //
  // ABI layout of send(address recipient, uint256 amount, bytes data):
  //   [4]  selector  9bd9bbc6
  //   [32] recipient (channelsAddr, left-padded)
  //   [32] amount    (uint256, left-padded)
  //   [32] offset    = 96  (bytes param head; points past the three fixed slots)
  //   [32] length    = 64  (userData is 64 bytes)
  //   [64] userData  = from(20) | amount_uint96(12) | to(20) | zero_uint96(12)
  //
  function encodeERC777Send(channelsAddr, fromAddr, toAddr, amountWei) {
    const userData =
      fromAddr.toLowerCase().replace(/^0x/, '')  +  // address: 20 bytes = 40 hex
      amountWei.toString(16).padStart(24, '0')   +  // uint96:  12 bytes = 24 hex
      toAddr.toLowerCase().replace(/^0x/, '')    +  // address: 20 bytes = 40 hex
      '000000000000000000000000';                    // uint96(0): 12 bytes = 24 hex
    // userData = 128 hex chars = 64 bytes, already a multiple of 32 → no tail padding

    return '0x'
      + '9bd9bbc6'                                                      // selector
      + channelsAddr.toLowerCase().replace(/^0x/, '').padStart(64, '0') // recipient
      + amountWei.toString(16).padStart(64, '0')                        // amount uint256
      + (96).toString(16).padStart(64, '0')                             // bytes offset
      + (64).toString(16).padStart(64, '0')                             // bytes length
      + userData;
  }

  async function topUpChannel() {
    if (!walletAddr) { alert('Connect wallet first'); return; }

    const from         = getAddress('from');
    const to           = getAddress('to');
    const tokenAddr    = document.getElementById('tokenAddr').value.trim();
    const channelsAddr = document.getElementById('channelsAddr').value.trim();
    const amountStr    = document.getElementById('topUpAmount').value.trim();

    if (!from)      { alert('Provide a "From" address'); return; }
    if (!to)        { alert('Provide a "To" address');   return; }
    if (!amountStr) { alert('Enter an amount');          return; }

    let amountWei;
    try {
      amountWei = parseHOPR(amountStr);
      if (amountWei === 0n) { alert('Amount must be greater than 0'); return; }
      // uint96 max = 2^96 - 1
      if (amountWei > 2n ** 96n - 1n) { alert('Amount exceeds uint96 max'); return; }
    } catch {
      alert('Invalid amount');
      return;
    }

    const statusEl = document.getElementById('topUpStatus');
    statusEl.textContent = 'Sending transaction…';

    try {
      const calldata = encodeERC777Send(channelsAddr, from, to, amountWei);
      const txHash = await window.ethereum.request({
        method: 'eth_sendTransaction',
        params: [{ from: walletAddr, to: tokenAddr, data: calldata }],
      });
      statusEl.textContent = 'Transaction sent: ' + txHash;
      // Refresh balance after send
      await refreshBalance();
    } catch (e) {
      statusEl.textContent = 'Error: ' + (e.message || JSON.stringify(e));
    }
  }

  // ── TicketRedeemed heatmap ────────────────────────────────────────────────

  let hmAborted = false;
  let hmPaused  = false;
  let hmRunning = false;
  let hmState   = null;  // saved state when paused; null = idle

  function updateHmButtons() {
    const loadBtn  = document.getElementById('hmLoadBtn');
    const pauseBtn = document.getElementById('hmPauseBtn');
    const abortBtn = document.getElementById('hmAbortBtn');
    loadBtn.disabled  = hmRunning;
    abortBtn.disabled = !hmRunning && !hmState;
    if (hmRunning) {
      pauseBtn.disabled    = false;
      pauseBtn.textContent = 'Pause';
    } else if (hmState) {
      pauseBtn.disabled    = false;
      pauseBtn.textContent = 'Resume';
    } else {
      pauseBtn.disabled    = true;
      pauseBtn.textContent = 'Pause';
    }
  }

  // Send a JSON-RPC batch (array of request objects) as a single network call.
  // Uses the wallet's legacy sendAsync API which both MetaMask and Rabby support.
  // Falls back to individual EIP-1193 window.ethereum.request calls if unavailable.
  function rpcBatch(requests) {
    return new Promise((resolve, reject) => {
      if (typeof window.ethereum.sendAsync === 'function') {
        window.ethereum.sendAsync(requests, (err, results) => {
          if (err) reject(new Error(err.message || JSON.stringify(err)));
          else     resolve(results);
        });
      } else {
        // Fallback: fire all requests in parallel via EIP-1193
        Promise.all(requests.map(r =>
          window.ethereum.request({ method: r.method, params: r.params })
            .then(result => ({ id: r.id, result }))
        )).then(resolve).catch(reject);
      }
    });
  }

  async function fetchLatestBlock() {
    if (!window.ethereum) { alert('Connect wallet first'); return; }
    const btn = document.getElementById('hmFetchLatestBtn');
    btn.disabled = true;
    btn.textContent = 'Fetching…';
    try {
      const hex = await window.ethereum.request({ method: 'eth_blockNumber' });
      document.getElementById('hmToBlock').value = parseInt(hex, 16);
    } catch (e) {
      alert('Failed to fetch latest block: ' + (e.message || JSON.stringify(e)));
    } finally {
      btn.disabled = false;
      btn.textContent = 'Fetch latest';
    }
  }

  function abortHeatmap() {
    hmAborted = true;
    hmState   = null;
    // UI resets when the running loop detects hmAborted and calls done()
  }

  function pauseResumeHeatmap() {
    if (hmRunning) {
      hmPaused = true;            // loop detects this and calls pause()
    } else if (hmState) {
      startHeatmapLoad();         // resume from saved state
    }
  }

  function loadHeatmap() {
    hmState = null;               // discard any saved state — fresh start
    startHeatmapLoad(true);       // auto-pause after first chunk with events
  }

  async function startHeatmapLoad(autoStopAfterFirst = false) {
    if (hmRunning) return;
    if (!window.ethereum) { alert('Connect wallet first'); return; }

    const channelsAddr = document.getElementById('channelsAddr').value.trim();
    const batchSize    = Math.max(1, parseInt(document.getElementById('hmBatchSize').value) || 100);
    const out     = document.getElementById('hmOutput');
    const bar     = document.getElementById('hmBar');
    const barText = document.getElementById('hmBarText');
    const prog    = document.getElementById('hmProgress');

    hmAborted = false;
    hmPaused  = false;
    hmRunning = true;
    prog.style.display = '';
    updateHmButtons();

    const TICKET_TOPIC = '0xed22f34d154d253a7f6fd477439be59080a1554aa0d0642686d64223ab544c8a';
    let chunks, ci, logs, blockTimes, pendingBlocks, pendingBatchI;

    if (hmState) {
      // Resume: restore saved state
      ({ chunks, ci, logs, blockTimes, pendingBlocks, pendingBatchI } = hmState);
      hmState = null;
    } else {
      // Fresh start: read config from UI and build chunk list
      const fromBlockDec = parseInt(document.getElementById('hmFromBlock').value) || 0;
      const toBlockRaw   = document.getElementById('hmToBlock').value.trim();
      const toBlock      = toBlockRaw ? '0x' + parseInt(toBlockRaw).toString(16) : 'latest';
      const logRange     = Math.max(1, parseInt(document.getElementById('hmLogRange').value) || 10000);

      bar.value = 0;
      barText.textContent = 'Resolving block range…';

      let toBlockNum;
      try {
        toBlockNum = toBlock === 'latest'
          ? parseInt(await window.ethereum.request({ method: 'eth_blockNumber' }), 16)
          : parseInt(toBlock, 16);
      } catch (e) {
        barText.textContent = 'Failed to resolve latest block: ' + (e.message || JSON.stringify(e));
        hmRunning = false;
        prog.style.display = 'none';
        updateHmButtons();
        return;
      }

      chunks = [];
      for (let b = toBlockNum; b >= fromBlockDec; b -= logRange)
        chunks.push([Math.max(b - logRange + 1, fromBlockDec), b]);

      ci            = 0;
      logs          = [];
      blockTimes    = {};
      pendingBlocks = null;
      pendingBatchI = 0;
    }

    // Called when fully done (all chunks processed or aborted).
    const done = () => {
      hmRunning = false;
      hmState   = null;
      prog.style.display = 'none';
      barText.textContent = '';
      updateHmButtons();
      renderHeatmap(logs, blockTimes);
    };

    // Called when the user pauses: serialise current position into hmState.
    const pause = () => {
      hmState = { chunks, ci, logs, blockTimes, pendingBlocks, pendingBatchI };
      hmRunning = false;
      bar.value = 0;
      barText.textContent = 'Paused — click Resume to continue';
      updateHmButtons();
      renderHeatmap(logs, blockTimes);
    };

    for (; ci < chunks.length; ci++) {
      if (hmAborted) { done(); return; }
      if (hmPaused)  { pause(); return; }   // pendingBlocks is null at this point

      const [chunkFrom, chunkTo] = chunks[ci];

      // ── Fetch log chunk (skipped when resuming mid-timestamp for this chunk) ─
      if (pendingBlocks === null) {
        bar.value = 0;
        barText.textContent = 'Log chunk ' + (ci + 1) + ' / ' + chunks.length
          + '  (blocks ' + chunkFrom.toLocaleString() + '–' + chunkTo.toLocaleString() + ')'
          + '  —  ' + logs.length + ' events so far';

        let chunkLogs;
        while (true) {
          try {
            chunkLogs = await window.ethereum.request({
              method: 'eth_getLogs',
              params: [{ address: channelsAddr, topics: [TICKET_TOPIC],
                         fromBlock: '0x' + chunkFrom.toString(16),
                         toBlock:   '0x' + chunkTo.toString(16) }],
            });
            break;
          } catch (e) {
            const msg = (e?.message ?? '').toLowerCase();
            const isRateLimit = msg.includes('429') || msg.includes('rate') ||
                                msg.includes('too many') || e?.code === -32005;
            if (!isRateLimit) {
              const lines = ['Error on log chunk ' + (ci + 1) + ' / ' + chunks.length
                           + ' (blocks ' + chunkFrom + '–' + chunkTo + '):'];
              if (e.code    !== undefined) lines.push('  code:    ' + e.code);
              if (e.message !== undefined) lines.push('  message: ' + e.message);
              if (e.data    !== undefined) lines.push('  data:    ' + JSON.stringify(e.data));
              lines.push('  raw: ' + JSON.stringify(e, Object.getOwnPropertyNames(e), 2));
              out.innerHTML = '<pre>' + lines.join('\n') + '</pre>';
              hmRunning = false;
              prog.style.display = 'none';
              updateHmButtons();
              return;
            }
            for (let s = 10; s > 0; s--) {
              barText.textContent = 'Rate limited on log fetch — retrying in ' + s + 's…';
              await new Promise(r => setTimeout(r, 1000));
              if (hmAborted || hmPaused) break;
            }
            if (hmAborted) { done(); return; }
            if (hmPaused)  { pause(); return; }
          }
        }
        if (hmAborted) { done(); return; }
        if (hmPaused)  { pause(); return; }

        logs.push(...chunkLogs);
        if (chunkLogs.length === 0) continue;

        pendingBlocks = [...new Set(chunkLogs.map(l => l.blockNumber))]
          .filter(b => blockTimes[b] === undefined)
          .sort((a, b) => parseInt(b, 16) - parseInt(a, 16));
        pendingBatchI = 0;

        if (pendingBlocks.length === 0) { pendingBlocks = null; continue; }
      }

      // ── Fetch timestamps for pendingBlocks ────────────────────────────────
      for (let i = pendingBatchI; i < pendingBlocks.length; i += batchSize) {
        if (hmAborted) { done(); return; }
        if (hmPaused)  { pendingBatchI = i; pause(); return; }

        const slice   = pendingBlocks.slice(i, i + batchSize);
        const idToHex = {};
        const payload = slice.map((hexNum, j) => {
          const id = i + j;
          idToHex[id] = hexNum;
          return { jsonrpc: '2.0', id, method: 'eth_getBlockByNumber', params: [hexNum, false] };
        });

        bar.value = Math.round(i / pendingBlocks.length * 100);
        barText.textContent = 'Log chunk ' + (ci + 1) + ' / ' + chunks.length
          + '  — timestamps ' + i + ' / ' + pendingBlocks.length
          + '  (' + logs.length + ' events total)';

        let results;
        while (true) {
          try {
            results = await rpcBatch(payload);
            const rl = results.find(r => {
              if (!r.error) return false;
              const m = (r.error.message ?? '').toLowerCase();
              return m.includes('429') || m.includes('rate') ||
                     m.includes('too many') || r.error.code === -32005;
            });
            if (rl) throw Object.assign(new Error(rl.error.message ?? 'rate limit'), { code: -32005 });
            break;
          } catch (e) {
            const msg = (e?.message ?? e?.toString() ?? '').toLowerCase();
            const isRateLimit = msg.includes('429') || msg.includes('rate') ||
                                msg.includes('too many') || e?.code === -32005;
            if (!isRateLimit) throw e;
            for (let s = 10; s > 0; s--) {
              barText.textContent = 'Rate limited on timestamps — retrying in ' + s + 's…';
              await new Promise(r => setTimeout(r, 1000));
              if (hmAborted || hmPaused) break;
            }
            if (hmAborted) { done(); return; }
            if (hmPaused)  { pendingBatchI = i; pause(); return; }
          }
        }

        for (const r of results)
          if (r.result) blockTimes[idToHex[r.id]] = parseInt(r.result.timestamp, 16);

        bar.value = Math.round((i + slice.length) / pendingBlocks.length * 100);
        barText.textContent = 'Log chunk ' + (ci + 1) + ' / ' + chunks.length
          + '  — timestamps ' + (i + slice.length) + ' / ' + pendingBlocks.length
          + '  (' + logs.length + ' events total)';

        renderHeatmap(logs, blockTimes);
      }

      pendingBlocks = null;
      pendingBatchI = 0;

      // Fresh Load: pause after the first chunk that produced events so the
      // user sees an immediate preview and can Resume to load the rest.
      if (autoStopAfterFirst) { autoStopAfterFirst = false; hmPaused = true; }
    }

    done();
  }

  function renderHeatmap(logs, blockTimes) {
    // Bucket events into UTC date+hour slots
    const counts = {};   // key: 'YYYY-MM-DDTHH'  →  count
    for (const log of logs) {
      const ts = blockTimes[log.blockNumber];
      if (ts === undefined) continue;
      const d   = new Date(ts * 1000);
      const key = d.toISOString().slice(0, 13); // 'YYYY-MM-DDTHH'
      counts[key] = (counts[key] || 0) + 1;
    }

    // Most recent date first so incremental renders lead with the latest data.
    const dates = [...new Set(Object.keys(counts).map(k => k.slice(0, 10)))].sort().reverse();
    if (dates.length === 0) {
      document.getElementById('hmOutput').innerHTML = 'No events with resolved timestamps.';
      return;
    }

    const maxCount = Math.max(...Object.values(counts));

    // Map count → shade character using log scale so a single large outlier
    // doesn't compress everything else to the lowest shade.
    // 0 → space, 1..max → ░ ▒ ▓ █  (log-interpolated).
    function shadeChar(count) {
      if (count === 0) return ' ';
      if (maxCount <= 1) return '░';
      const idx = Math.min(Math.round((Math.log(count) / Math.log(maxCount)) * 3), 3);
      return '░▒▓█'[idx];
    }

    function esc(s) {
      return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;');
    }

    // Each cell is 2 chars wide (shade + space) to match the "HH " header width.
    let html = '<pre style="font-size:1.4em">';

    // Header: date label + hour columns
    html += '            '; // 12 spaces to align with 'YYYY-MM-DD  '
    for (let h = 0; h < 24; h++) html += String(h).padStart(2, '0') + ' '; // 3 chars: HH + space
    html += '\n';

    for (const date of dates) {
      html += date + '  '; // 10 + 2 = 12 chars
      for (let h = 0; h < 24; h++) {
        const key   = date + 'T' + String(h).padStart(2, '0');
        const count = counts[key] || 0;
        const ch    = shadeChar(count);
        const tip   = esc(date + ' ' + String(h).padStart(2, '0') + ':00 UTC — ' + count + ' event' + (count !== 1 ? 's' : ''));
        // Three chars per column: 2 shade chars + space, matching header "HH " width
        html += '<span data-tip="' + tip + '">' + ch + ch + '\u00a0</span>';
      }
      html += '\n';
    }
    // Detailed legend inside the same <pre> so font size and family are identical.
    const SHADE_CHARS = ['░', '▒', '▓', '█'];
    const shadeRanges = [null, null, null, null];
    for (let c = 1; c <= maxCount; c++) {
      const level = maxCount <= 1 ? 0
        : Math.min(Math.round((Math.log(c) / Math.log(maxCount)) * 3), 3);
      if (!shadeRanges[level]) shadeRanges[level] = [c, c];
      else shadeRanges[level][1] = c;
    }
    const legendParts = ['[  ]: 0 events'];
    for (let level = 0; level < 4; level++) {
      if (!shadeRanges[level]) continue;
      const [min, max] = shadeRanges[level];
      const ch    = SHADE_CHARS[level];
      const range = min === max ? min + ' event' + (min !== 1 ? 's' : '')
                                : min + '\u2013' + max + ' events';
      legendParts.push(ch + ch + ': ' + range);
    }
    html += '\n' + legendParts.join(', ');
    html += '</pre>';

    document.getElementById('hmOutput').innerHTML = html;
  }

  // Tooltip — shared across the whole page
  const _tip = document.getElementById('hm-tooltip');
  document.addEventListener('mouseover',  e => { if (e.target.dataset.tip) { _tip.textContent = e.target.dataset.tip; _tip.style.display = 'block'; } });
  document.addEventListener('mouseout',   e => { if (e.target.dataset.tip) { _tip.style.display = 'none'; } });
  document.addEventListener('mousemove',  e => { if (_tip.style.display !== 'none') { _tip.style.left = (e.clientX + 14) + 'px'; _tip.style.top = (e.clientY + 14) + 'px'; } });

</script>

<!-- Tooltip element (no styling page-wide, but needs position:fixed to work) -->

</body>
</html>
